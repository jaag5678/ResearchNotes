%\documentclass[xcolor=dvipsnames]{beamer}
\documentclass[notes, xcolor=dvipsnames]{beamer}

\usetheme{Warsaw}

\usepackage{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}

\newcommand{\po}{\textcolor{BlueViolet}{po}}
\newcommand{\xpo}{\textcolor{BlueViolet}{xpo}}
\newcommand{\rf}{\textcolor{Green}{rf}}
\newcommand{\co}{\textcolor{BurntOrange}{co}}
\newcommand{\coe}{\textcolor{BurntOrange}{coe}}
\newcommand{\mo}{\textcolor{Red}{mo}}
\newcommand{\hb}{\textcolor{NavyBlue}{hb}}
\newcommand{\fr}{\textcolor{RubineRed}{fr}}
\newcommand{\fre}{\textcolor{RubineRed}{fre}}
\newcommand{\xhb}{\textcolor{NavyBlue}{xhb}}
\newcommand{\rfe}{\textcolor{Green}{rfe}}
\newcommand{\rfi}{\textcolor{Green}{rfi}}
\newcommand{\sw}{\textcolor{BurntOrange}{sw}}
\newcommand{\jhb}{\textcolor{NavyBlue}{jhb}}
\newcommand{\jmo}{\textcolor{Red}{jmo}}
\newcommand{\eco}{\textcolor{WildStrawberry}{eco}}
\newcommand{\rmw}{\textcolor{Bittersweet}{rmw}}
\newcommand{\imp}{\textcolor{LimeGreen}{imp}}


%Misc coloring for binary relations

\title{Robustness Between Weak Memory Models}
\subtitle{Soham Chakraborty}

\author{Presentation by \\ Akshay Gopalakrishnan}

\begin{document}
    
    \begin{frame}

        \maketitle

    \end{frame}

    \begin{frame}{Introduction}

        \begin{itemize}
            \item Robustness is a property that a program can have given two memory models.
            \item A program executing under a memory model $K$ is Robust against memory model $M$ if all consistent executions under $K$ are also consistent under $M$.
            \item This property is useful in ensuring safe portability of programs across different platforms.
            \item However, as far as memory models are concerned, Robustness is maintained only against Sequential Consistency (SC).
            \item This paper analyzes robustness against weaker memory models such as x86-TSO, ARMv7 and ARMv8. 
            \item Robustness conditions are established against each of these models.
            \item An analysis tool is also developed to ensure a program is Robust or if not, adding fence instructions to ensure Robustness.   
        \end{itemize}

    \end{frame}

    \begin{frame}{Examples of Robustness}

        As an example, consider robustness of programs running on ARM against x86. 
        \begin{figure}
            \makebox[\textwidth][c]{
                \includegraphics{LB_SB_ROBUSTNESS_EX.PNG}
            }
        \end{figure}
        %Explain that TSO exhibits SB but SC does not. Which means SB-TSO is not Robust against SC.
        In the above figure, program SB's outcome $a=1 \wedge b=1$ is allowed by both x86 and ARM. 
        But for the program LB, the outcome $a=1 \wedge b=1$ is allowed by ARM but not by x86.

        Thus, program SB is x86 robust while LB is not. 

    \end{frame}

    \begin{frame}{Robustnes Definition}

        \begin{center}
            \textit{A program P is M-K robust if all its K-consistent executions are also M-consistent.} 
        \end{center}
        
        %Give example of SB program being TSO-ARMv7 robust.
        So for our example above:
        \begin{itemize}
            \item SB is x86-ARM robust.
            \item LB is not x86-ARM robust.
        \end{itemize} 

    \end{frame}

    \begin{frame}{Axiomatic Specification of Memory Consistency Models}

        \begin{itemize}
            \item Define binary relations (mainly partial orders) between program constructs Read/Write/RMW/Fence. 
            \item Per-execution semantics. 
            \item Specify axioms based on relations, which are acyclic/irreflexivity conditions on execution graphs. 
        \end{itemize}

    \end{frame}

    \begin{frame}{Preliminary Definitions of Binary Relations}

        %Put basic ones like po/rf/co/fr
        Binary relations:
        \begin{itemize}
            \item {\po} - Program order per thread.
            \item {\rf} - Between a read and the write from which its read value comes.
            \item {\co} - Order between writes/updates to same location.
            \item {\rmw} - Order between a Read and a Write which form an Atomic update (read-modify-writes).
            \item {\fr} - $\rf^{-1};\co$ read-happens before (also abbreviated as reads-before ).
            \item {\eco} - $\rfe \cup \coe \cup \fre$ called as extended coherence order (take all the external preliminary relations apart from \po).
            \item 
        \end{itemize}


    \end{frame}

    \begin{frame}{SC}

        SC with the above relations can be defined as:
        \begin{itemize}
            \item $\po \ \cup \ \rf \ \cup \fr \ \cup \ \co$ acyclic.
            \item $\rmw \cap \fre;\coe = \phi$.
        \end{itemize}

        %TSO definition

    \end{frame}

    \begin{frame}{x86-TSO}

        Some additional binary relations (derived)
        \begin{itemize}
            \item {\xpo} - $((W * W) \cup (R * W) \cup (R * R)) \cap \po$ preserved program order.
            \item {\imp} - $\po;[dom(\rmw) \cup F] \cup [codom(\rmw) \cup F];\po$ implied order.
            \item {\xhb} - $\xpo \cup \imp \cup \rfe \cup \fr \cup co$ x86 happens-before.
        \end{itemize}

        x86 is then defined as 
        \begin{itemize}
            \item $\po \ \cup \ \rf \ \cup \fr \ \cup \ \co$ acyclic.
            \item $\rmw \cap \fre;\coe = \phi$.
            \item $\xhb$ acyclic.
        \end{itemize}

    \end{frame}
    

    \begin{frame}{Robustness Conditions: Intuition}

        %mention the Paragraph based intuition on page 4 just before the Robustness conditions.

    \end{frame}

    \begin{frame}{SC-x86TSO Robustness Condition}

        %For each of the condition (in the union relation), mention intuition as to why it is so.
        %do this only for SC-TSO as the rest are almost same and personally I do not find it worth going in-depth for each.

    \end{frame}

    \begin{frame}{Checking and Enforcing Robustness}

        \begin{itemize}
            \item Take the Control Flow Graph of the program.
            \item Build a Memory-access pair graph (MPG) capturing two important edge relations (eco and epo).
            \item If MPG has a cycle, check each access pair whether ordered, as per a condition based on M-K Robustness.
            \item If every pair is ordered, program is M-K Robust.
            \item Else, insert appropriate fences between memory access pairs that are not ordered. 
        \end{itemize}

    \end{frame}

    \begin{frame}{Experimental Evaluation}

    \end{frame}

    \begin{frame}{Thank you}
        Questions?
    \end{frame}


\end{document}