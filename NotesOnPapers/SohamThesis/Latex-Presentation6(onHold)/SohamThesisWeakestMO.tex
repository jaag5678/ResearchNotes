%Soham Chakraborty's PhD Thesis done at MPI-SWS under the supervision of Professor Viktor Vafeiadis
\documentclass[xcolor={dvipsnames}]{beamer}
%\documentclass[notes]{beamer}

\usetheme{Warsaw}

\usepackage{inputenc}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{tasks}
\usepackage{amsmath}
\ifodd\textwidth
  \addtolength{\textwidth}{1sp}
\fi

\title{Correct Compilation of Relaxed Memory Concurrency}
\subtitle{PhD Thesis \\ of \\ Soham Chakraborty}

\author{Presented by \\ Akshay Gopalakrishnan}

\begin{document}
    
    \begin{frame}
        \maketitle
    \end{frame}

    \begin{frame}{Introduction}

        \begin{itemize}
            \item Relaxed Memory Concurrency (shared memory Concurrency)
            \item Propose a Relaxed Memory Model based on Event Structures.
            \item Test the programmibility factors of the model.
            \item Prove Compilation correctness to various architectures.  
            \item Validate program transformations in LLVM.  
        \end{itemize}
        
    \end{frame}

    \begin{frame}{Shared Memory Concurrency }
        
        Multicore programming.
        Programs run accross many cores in parallel.
        Sharing information when needed using a common shared memory.
        Intuitively, interleaving semantics relied on to reason about multicore programs.

        %Attach figure here of the Hardware memory model which has CPU and just one big chunk of shared memory.
    \end{frame}

    \begin{frame}{Relaxed Memory Concurrency}
        
        Hardwares typically have features which violate interleaving semantics.
        Gains tremendous performance benefits doing so. 
        Relaxing the interleaving semantics gives rise to more possibilities of program output. 

    \end{frame}

    \begin{frame}{Hardware Memory Models (HMM)}
        
        Hardware typically use Read/Write buffers, Cache systems and Speculation which gives rise to relaxed behaviors.
        This thesis presents three of such hardwares:
        \begin{itemize}
            \item x86-Total Store order.
            \item PowerPC.
            \item ARM (v7/v8).
        \end{itemize}

    \end{frame}

    \begin{frame}{HMM: x86-TSO}
        
        %Figure showing write buffers.
        %Brief explaination of what a read does to search its correct value.

    \end{frame}

    %Perhaps showcase the store buffering example here to show that x86 relaxes interleaving semantics.

    \begin{frame}{HMM: PowerPC}

        %Figure showing Star Topology model (hints towards Non-MCA and usage of cache)
        %Briefly explain its model.

    \end{frame}

    %List out the relaxed features of the powerPC model in a subsequent slide here. 

    %Put like two examples, each one showcasing one feature of the powerPc model.

    \begin{frame}{HMM: ARMv7/v8}

        %Figure showing the flow model of ARM 
        %Explain in brief its features.    
    
    \end{frame}

    \begin{frame}{Software Memory Models (SMM)}

        Programming languages at the software layer also need a relaxed memory model to be able to use it at the software layer.
        Relaxation of interleaving semantics open up for doing program transformations for performance.
        Model needs to support portability of code so that it can run on multiple architectures.
    \end{frame}

    \begin{frame}{SMM: Data Race Free 0 (DRF0)}
        
    \end{frame}

    \begin{frame}{SMM: Java}
        
    \end{frame}

    \begin{frame}{SMM: C11}
        
    \end{frame}

    \begin{frame}{Additional Problems at the SMM layer}
        %OOTA
        %Transformations by eliminating false dependencies.
        %Data Races 
    \end{frame}

    \begin{frame}{Explaining Behaviors in Relaxed Memory Models}
        
    \end{frame}

    \begin{frame}{Operational Approach}
        
    \end{frame}

    \begin{frame}{Transformational Approach}
        
    \end{frame}

    \begin{frame}{Axiomatic Approach}
        
    \end{frame}



\end{document}